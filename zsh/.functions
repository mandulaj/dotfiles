#!/usr/bin/env bash

cheat() {
    local ARG="${1:-README}"
    if [[ "$ARG" == "cd" ]]; then
        cd $HOME/Documents/Personal/Cheatsheets/commands
    else
        pygmentize -O style=native "$HOME/Documents/Personal/Cheatsheets/commands/$ARG.md"
    fi
}


cdd() {
    cd /run/media/$USER/$1
}



snapcd() {
    if [[ $1 == -h || $1 == --help ]]; then
        echo 'snapcd - cd to a snapshot'
        echo '    snapcd -h/--help       - Print this help'
        echo '    snapcd [-r[n]] [snap]  - Jump to current location to `n`-th last snapshot, or snapshot `snap` - Default jump to last snapshot'
        echo '                           - if executed in snapshot without parameters, jumps back to main FS'
        echo ''
        echo '    snapcd -a[n] [snap]    - Jump to base directory of `n`-th last snapshot or snapshot `snap`'

        return;
    fi
    SNAP_DIR="/home/.snapshots"
    PWD=`pwd -P`

    ## Absolute change to latest snapshot ( -a[n] )
    if [[ $1 == -a* ]]; then

        # Get any characters after -a
        OFFSET=$(echo $1 | cut -c 3-)
        if ! [[ "$OFFSET" =~ '^[1-9]+[0-9]*$' ]]; then
            # Set the offset to 1 if the characters aren't numeric...
            OFFSET=1
        fi

        REL_PATH=""
        BASE=$SNAP_DIR
        # Use 2nd param as snapshot number, else use the offset
        ID=${2:-$(ls -1 /home/.snapshots | tail -n$OFFSET | head -1)}

        echo "Absolute jump to snapshot $ID"

    # Change back to original
    elif [[ "$PWD" =~ ^/home/.snapshots/[0-9]+/snapshot/jakub* ]]; then
        # We were in a snapshot, jump back to current snapshot
        ID=0

        if [[ $1 == -r* ]]; then
            OFFSET=$(echo $1 | cut -c 3-)
            if ! [[ "$OFFSET" =~ '^[1-9]+[0-9]*$' ]]; then
                OFFSET=1
            fi
            ID=$(ls -1 /home/.snapshots | tail -n$OFFSET | head -1)
            BASE=$SNAP_DIR
        else
            REL_PATH=`pwd -P | cut -d/ -f7-`
            BASE="/home/jakub"
        fi

    else
    # Change to snapshot in relative way

        # Make sure we are in /home
        if [[ "$PWD" =~ ^/home/jakub.* ]]; then
            REL_PATH=`pwd -P | cut -d/ -f4-`
        else
            echo "You are not at HOME :)"
            REL_PATH=""
            return;
        fi

        # Jump to -r[nth] last snapshot
        if [[ $1 == -r* ]]; then
            OFFSET=$(echo $1 | cut -c 3-)
            if ! [[ "$OFFSET" =~ '^[1-9]+[0-9]*$' ]]; then
                OFFSET=1
            fi
            ID=$(ls -1 /home/.snapshots | tail -n$OFFSET | head -1)
        else
            OFFSET=1

            ID=${1:-$(ls -1 /home/.snapshots | tail -n1)}
        fi

        BASE=$SNAP_DIR

        echo "Relative jump to snapshot $ID"
    fi


    # Change back case
    if [[ "$ID" -eq "0" ]]; then
        DESTINATION="$BASE/$REL_PATH"

    else

        if [[ ! -d "$SNAP_DIR/$ID" ]]; then
            echo "Snapshot $ID does not exist"
            return
        fi
        DESTINATION="$BASE/$ID/snapshot/jakub/$REL_PATH"
        grep "<date>" "$BASE/$ID/info.xml" | sed -E 's|.*<date>(.*)</date>.*|\1|'
    fi

    if [[ -d "$DESTINATION" ]]; then
        cd $DESTINATION;
    else
        echo "Directory $REL_PATH does not exist"
    fi
}


# Proxy Firefox
#
#
socksfox() {
    local socket="${1:-openwrt-public2}"
    echo "$socket"
    ssh -N -D 1337 $socket &
    firefox -P socks_proxy;
    fg
}




for_all_servers() {
    local servers_file="$HOME/.pbl_servers"
    if [[ ! -f "$servers_file" ]]; then
        echo "Error: Server list file ($servers_file) not found!"
        return 1
    fi

    local servers=($(cat "$servers_file"))

    if [[ -z "$1" ]]; then
        echo "Usage: run_on_servers '<command>'"
        return 1
    fi

    for server in "${servers[@]}"; do
        echo "\033[1mExecuting on $server...\033[0m"
        ssh -q -t "$server" "$1"
    done
}


autoload -Uz add-zsh-hook

function _brb_capture_command() {
    local cmd_str="$1"

    # Check if the command being run is essentially just 'fg' (ignoring 'brb')
    # We strip 'brb' temporarily to see if the core command is 'fg'
    local core_cmd=$(echo "$cmd_str" | sed -E 's/[;&|[:space:]]+brb[[:space:]]*$//')

    # If the user is running 'fg' (bare, without arguments like %2)
    if [[ "$core_cmd" == "fg" ]]; then
        # Zsh Magic: Find the job ID of the "current" job (marked with +)
        # 1. (r)*:+* -> reverse search for value containing :+: (the current job marker)
        # 2. (k)      -> return the key (Job ID) instead of the value
        local job_id=${(k)jobstates[(r)*:+*]}

        # If we found a valid job ID, grab its original text
        if [[ -n "$job_id" ]]; then
            typeset -g _BRB_CMD="${jobtexts[$job_id]}"
            return
        fi
    fi

    # Standard case: Just save exactly what the user typed
    typeset -g _BRB_CMD="$cmd_str"
}

# 3. Add the hook to preexec
add-zsh-hook preexec _brb_capture_command

# Function for alert notifications using ntfy.sh
brb() {
    local exit_status=$?  # Capture the exit status before doing anything else
    local token=$(< ~/.ntfy_token)  # Securely read the token
    local status_icon="$([ $exit_status -eq 0 ] && echo white_check_mark || echo x)"
    #local last_command=$(history | tail -n1 | sed -e 's/^[[:space:]]*[0-9]\{1,\}[[:space:]]*//' -e 's/[;&|][[:space:]]*alert$//')
    local last_command=$(echo "$_BRB_CMD" | sed -E 's/[;&|[:space:]]+brb[[:space:]]*$//')
    local hostname=$(hostname)

    curl -s -X POST "https://ntfy.mandula.cz/alerts" \
        -H "Authorization: Bearer $token" \
        -H "Title: Terminal ($hostname)" \
        -H "X-Priority: 3" \
        -H "Tags: $status_icon" \
        -d "Command: $last_command (Exit: $exit_status)" > /dev/null

    #echo "Tags: $status_icon"
    #echo "$last_command (Exit: $exit_status)"
}


